#include "PhysicsCharacterSystem.h"

namespace Carrot::ECS {
    PhysicsCharacterSystem::PhysicsCharacterSystem(Carrot::ECS::World& world)
            : Carrot::ECS::LogicSystem<Carrot::ECS::TransformComponent, Carrot::ECS::PhysicsCharacterComponent>(world) {
    }

    void PhysicsCharacterSystem::tick(double dt) {
        // no op
    }

    void PhysicsCharacterSystem::prePhysics() {
        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            bool inWorld = characterComp.character.isInWorld();
            if(characterComp.firstFrame || !inWorld) {
                characterComp.character.setWorldTransform(transformComp.computeGlobalPhysicsTransform());
                if (characterComp.firstFrame) {
                    characterComp.character.addToWorld();
                    inWorld = true;
                }
                characterComp.firstFrame = false;
            }

            if(inWorld) {
                characterComp.character.prePhysics();
            }
        });
    }

    void PhysicsCharacterSystem::postPhysics() {
        parallelForEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            const bool inWorld = characterComp.character.isInWorld();
            if(inWorld) {
                characterComp.character.postPhysics();

                Math::Transform characterWorldTransform = characterComp.character.getWorldTransform();
                if (!characterComp.applyRotation) {
                    characterWorldTransform.rotation = transformComp.computeFinalOrientation();
                }
                transformComp.setGlobalTransform(characterWorldTransform);
            }
        });

        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            characterComp.dispatchEventsPostPhysicsMainThread();
        });
    }

    void PhysicsCharacterSystem::onFrame(Carrot::Render::Context renderContext) {
        // TODO: autogenerated
    }

    std::unique_ptr <Carrot::ECS::System> PhysicsCharacterSystem::duplicate(Carrot::ECS::World& newWorld) const {
        std::unique_ptr<PhysicsCharacterSystem> result = std::make_unique<PhysicsCharacterSystem>(newWorld);
        return result;
    }

    void PhysicsCharacterSystem::reload() {
        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            characterComp.firstFrame = true;
            characterComp.character.addToWorld();
        });
    }

    void PhysicsCharacterSystem::unload() {
        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            characterComp.character.removeFromWorld();
        });
    }
}